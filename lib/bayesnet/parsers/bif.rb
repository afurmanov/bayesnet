# Autogenerated from a Treetop grammar. Edits may be lost.


require "treetop"

module Bayesnet
  module Parsers
    module Bif
      include Treetop::Runtime

      def root
        @root ||= :CompilationUnit
      end

      include Bayesnet::Parsers::Builder

      module CompilationUnit0
        def SEP1
          elements[0]
        end

        def NetworkDeclaration
          elements[1]
        end

        def list
          elements[2]
        end

        def SEP2
          elements[3]
        end
      end

      module CompilationUnit1
        def nodes
          list.elements.select { |e| e.respond_to?(:node) }.map(&:node)
        end

        def cpts
          list.elements.select { |e| e.respond_to?(:cpt) }.map(&:cpt)
        end
      end

      def _nt_CompilationUnit
        start_index = index
        if node_cache[:CompilationUnit].has_key?(index)
          cached = node_cache[:CompilationUnit][index]
          if cached
            node_cache[:CompilationUnit][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_SEP
        s0 << r1
        if r1
          r2 = _nt_NetworkDeclaration
          s0 << r2
          if r2
            s3, i3 = [], index
            loop do
              i4 = index
              r5 = _nt_VariableDeclaration
              if r5
                r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
                r4 = r5
              else
                r6 = _nt_ProbabilityDeclaration
                if r6
                  r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                  r4 = r6
                else
                  @index = i4
                  r4 = nil
                end
              end
              if r4
                s3 << r4
              else
                break
              end
            end
            r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
            s0 << r3
            if r3
              r7 = _nt_SEP
              s0 << r7
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(CompilationUnit0)
          r0.extend(CompilationUnit1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:CompilationUnit][start_index] = r0

        r0
      end

      module NetworkDeclaration0
        def SEP1
          elements[0]
        end

        def NETWORK
          elements[1]
        end

        def SEP2
          elements[2]
        end

        def WORD
          elements[3]
        end

        def SEP3
          elements[4]
        end

        def NetworkContent
          elements[5]
        end

        def SEP4
          elements[6]
        end
      end

      def _nt_NetworkDeclaration
        start_index = index
        if node_cache[:NetworkDeclaration].has_key?(index)
          cached = node_cache[:NetworkDeclaration][index]
          if cached
            node_cache[:NetworkDeclaration][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_SEP
        s0 << r1
        if r1
          r2 = _nt_NETWORK
          s0 << r2
          if r2
            r3 = _nt_SEP
            s0 << r3
            if r3
              r4 = _nt_WORD
              s0 << r4
              if r4
                r5 = _nt_SEP
                s0 << r5
                if r5
                  r6 = _nt_NetworkContent
                  s0 << r6
                  if r6
                    r7 = _nt_SEP
                    s0 << r7
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(NetworkDeclaration0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:NetworkDeclaration][start_index] = r0

        r0
      end

      module NetworkContent0
        def SEP
          elements[0]
        end

        def Property
          elements[1]
        end
      end

      module NetworkContent1
        def SEP1
          elements[0]
        end

        def SEP2
          elements[3]
        end

        def SEP3
          elements[5]
        end
      end

      def _nt_NetworkContent
        start_index = index
        if node_cache[:NetworkContent].has_key?(index)
          cached = node_cache[:NetworkContent][index]
          if cached
            node_cache[:NetworkContent][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_SEP
        s0 << r1
        if r1
          if (match_len = has_terminal?("{", false, index))
            r2 = true
            @index += match_len
          else
            terminal_parse_failure('"{"')
            r2 = nil
          end
          s0 << r2
          if r2
            s3, i3 = [], index
            loop do
              i4, s4 = index, []
              r5 = _nt_SEP
              s4 << r5
              if r5
                r6 = _nt_Property
                s4 << r6
              end
              if s4.last
                r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
                r4.extend(NetworkContent0)
              else
                @index = i4
                r4 = nil
              end
              if r4
                s3 << r4
              else
                break
              end
            end
            r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
            s0 << r3
            if r3
              r7 = _nt_SEP
              s0 << r7
              if r7
                if (match_len = has_terminal?("}", false, index))
                  r8 = true
                  @index += match_len
                else
                  terminal_parse_failure('"}"')
                  r8 = nil
                end
                s0 << r8
                if r8
                  r9 = _nt_SEP
                  s0 << r9
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(NetworkContent1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:NetworkContent][start_index] = r0

        r0
      end

      module VariableDeclaration0
        def SEP1
          elements[0]
        end

        def VARIABLE
          elements[1]
        end

        def SEP2
          elements[2]
        end

        def probabilityVariableName
          elements[3]
        end

        def SEP3
          elements[4]
        end

        def variableContent
          elements[5]
        end

        def SEP4
          elements[6]
        end
      end

      module VariableDeclaration1
        def node
          values = variableContent.values
          [probabilityVariableName.text_value.to_sym, values]
        end
      end

      def _nt_VariableDeclaration
        start_index = index
        if node_cache[:VariableDeclaration].has_key?(index)
          cached = node_cache[:VariableDeclaration][index]
          if cached
            node_cache[:VariableDeclaration][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_SEP
        s0 << r1
        if r1
          r2 = _nt_VARIABLE
          s0 << r2
          if r2
            r3 = _nt_SEP
            s0 << r3
            if r3
              r4 = _nt_probabilityVariableName
              s0 << r4
              if r4
                r5 = _nt_SEP
                s0 << r5
                if r5
                  r6 = _nt_variableContent
                  s0 << r6
                  if r6
                    r7 = _nt_SEP
                    s0 << r7
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(VariableDeclaration0)
          r0.extend(VariableDeclaration1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:VariableDeclaration][start_index] = r0

        r0
      end

      module VariableContent0
        def SEP
          elements[0]
        end

        def Property
          elements[1]
        end
      end

      module VariableContent1
        def SEP1
          elements[0]
        end

        def list
          elements[2]
        end

        def SEP2
          elements[3]
        end

        def SEP3
          elements[5]
        end
      end

      module VariableContent2
        def values
          list.elements.select { |e| e.respond_to?(:values) }.map(&:values).flatten
        end
      end

      def _nt_variableContent
        start_index = index
        if node_cache[:variableContent].has_key?(index)
          cached = node_cache[:variableContent][index]
          if cached
            node_cache[:variableContent][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_SEP
        s0 << r1
        if r1
          if (match_len = has_terminal?("{", false, index))
            r2 = true
            @index += match_len
          else
            terminal_parse_failure('"{"')
            r2 = nil
          end
          s0 << r2
          if r2
            s3, i3 = [], index
            loop do
              i4 = index
              i5, s5 = index, []
              r6 = _nt_SEP
              s5 << r6
              if r6
                r7 = _nt_Property
                s5 << r7
              end
              if s5.last
                r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
                r5.extend(VariableContent0)
              else
                @index = i5
                r5 = nil
              end
              if r5
                r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
                r4 = r5
              else
                r8 = _nt_variableDiscrete
                if r8
                  r8 = SyntaxNode.new(input, (index-1)...index) if r8 == true
                  r4 = r8
                else
                  @index = i4
                  r4 = nil
                end
              end
              if r4
                s3 << r4
              else
                break
              end
            end
            r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
            s0 << r3
            if r3
              r9 = _nt_SEP
              s0 << r9
              if r9
                if (match_len = has_terminal?("}", false, index))
                  r10 = true
                  @index += match_len
                else
                  terminal_parse_failure('"}"')
                  r10 = nil
                end
                s0 << r10
                if r10
                  r11 = _nt_SEP
                  s0 << r11
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(VariableContent1)
          r0.extend(VariableContent2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:variableContent][start_index] = r0

        r0
      end

      module VariableDiscrete0
        def SEP1
          elements[0]
        end

        def VARIABLETYPE
          elements[1]
        end

        def SEP2
          elements[2]
        end

        def DISCRETE
          elements[3]
        end

        def SEP3
          elements[4]
        end

        def SEP4
          elements[6]
        end

        def DECIMAL_LITERAL
          elements[7]
        end

        def SEP5
          elements[8]
        end

        def SEP6
          elements[10]
        end

        def SEP7
          elements[12]
        end

        def variableValuesList
          elements[13]
        end

        def SEP8
          elements[14]
        end

        def SEP9
          elements[16]
        end

        def SEP10
          elements[18]
        end
      end

      module VariableDiscrete1
        def values
          variableValuesList.values
        end
      end

      def _nt_variableDiscrete
        start_index = index
        if node_cache[:variableDiscrete].has_key?(index)
          cached = node_cache[:variableDiscrete][index]
          if cached
            node_cache[:variableDiscrete][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_SEP
        s0 << r1
        if r1
          r2 = _nt_VARIABLETYPE
          s0 << r2
          if r2
            r3 = _nt_SEP
            s0 << r3
            if r3
              r4 = _nt_DISCRETE
              s0 << r4
              if r4
                r5 = _nt_SEP
                s0 << r5
                if r5
                  if (match_len = has_terminal?("[", false, index))
                    r6 = true
                    @index += match_len
                  else
                    terminal_parse_failure('"["')
                    r6 = nil
                  end
                  s0 << r6
                  if r6
                    r7 = _nt_SEP
                    s0 << r7
                    if r7
                      r8 = _nt_DECIMAL_LITERAL
                      s0 << r8
                      if r8
                        r9 = _nt_SEP
                        s0 << r9
                        if r9
                          if (match_len = has_terminal?("]", false, index))
                            r10 = true
                            @index += match_len
                          else
                            terminal_parse_failure('"]"')
                            r10 = nil
                          end
                          s0 << r10
                          if r10
                            r11 = _nt_SEP
                            s0 << r11
                            if r11
                              if (match_len = has_terminal?("{", false, index))
                                r12 = true
                                @index += match_len
                              else
                                terminal_parse_failure('"{"')
                                r12 = nil
                              end
                              s0 << r12
                              if r12
                                r13 = _nt_SEP
                                s0 << r13
                                if r13
                                  r14 = _nt_variableValuesList
                                  s0 << r14
                                  if r14
                                    r15 = _nt_SEP
                                    s0 << r15
                                    if r15
                                      if (match_len = has_terminal?("}", false, index))
                                        r16 = true
                                        @index += match_len
                                      else
                                        terminal_parse_failure('"}"')
                                        r16 = nil
                                      end
                                      s0 << r16
                                      if r16
                                        r17 = _nt_SEP
                                        s0 << r17
                                        if r17
                                          if (match_len = has_terminal?(";", false, index))
                                            r18 = true
                                            @index += match_len
                                          else
                                            terminal_parse_failure('";"')
                                            r18 = nil
                                          end
                                          s0 << r18
                                          if r18
                                            r19 = _nt_SEP
                                            s0 << r19
                                          end
                                        end
                                      end
                                    end
                                  end
                                end
                              end
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(VariableDiscrete0)
          r0.extend(VariableDiscrete1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:variableDiscrete][start_index] = r0

        r0
      end

      module VariableValuesList0
        def SEP
          elements[0]
        end

        def probabilityVariableValue
          elements[1]
        end
      end

      module VariableValuesList1
        def SEP
          elements[0]
        end

        def probabilityVariableValue
          elements[1]
        end

        def list
          elements[2]
        end
      end

      module VariableValuesList2
        def values
          [probabilityVariableValue.value] + list.elements.map { |e| e.elements[1].value }.flatten
        end
      end

      def _nt_variableValuesList
        start_index = index
        if node_cache[:variableValuesList].has_key?(index)
          cached = node_cache[:variableValuesList][index]
          if cached
            node_cache[:variableValuesList][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_SEP
        s0 << r1
        if r1
          r2 = _nt_probabilityVariableValue
          s0 << r2
          if r2
            s3, i3 = [], index
            loop do
              i4, s4 = index, []
              r5 = _nt_SEP
              s4 << r5
              if r5
                r6 = _nt_probabilityVariableValue
                s4 << r6
              end
              if s4.last
                r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
                r4.extend(VariableValuesList0)
              else
                @index = i4
                r4 = nil
              end
              if r4
                s3 << r4
              else
                break
              end
            end
            r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
            s0 << r3
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(VariableValuesList1)
          r0.extend(VariableValuesList2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:variableValuesList][start_index] = r0

        r0
      end

      module ProbabilityVariableValue0
        def value
          self.text_value.to_sym
        end
      end

      def _nt_probabilityVariableValue
        start_index = index
        if node_cache[:probabilityVariableValue].has_key?(index)
          cached = node_cache[:probabilityVariableValue][index]
          if cached
            node_cache[:probabilityVariableValue][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_VALUE
        r0.extend(ProbabilityVariableValue0)
        r0.extend(ProbabilityVariableValue0)

        node_cache[:probabilityVariableValue][start_index] = r0

        r0
      end

      module ProbabilityDeclaration0
        def SEP1
          elements[0]
        end

        def PROBABILITY
          elements[1]
        end

        def SEP2
          elements[2]
        end

        def probabilityVariablesList
          elements[3]
        end

        def SEP3
          elements[4]
        end

        def probabilityContent
          elements[5]
        end

        def SEP4
          elements[6]
        end
      end

      module ProbabilityDeclaration1
        def cpt
          { variable: probabilityVariablesList.value,
            parents: probabilityVariablesList.parents,
            cpt: probabilityContent.cpt}
        end
      end

      def _nt_ProbabilityDeclaration
        start_index = index
        if node_cache[:ProbabilityDeclaration].has_key?(index)
          cached = node_cache[:ProbabilityDeclaration][index]
          if cached
            node_cache[:ProbabilityDeclaration][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_SEP
        s0 << r1
        if r1
          r2 = _nt_PROBABILITY
          s0 << r2
          if r2
            r3 = _nt_SEP
            s0 << r3
            if r3
              r4 = _nt_probabilityVariablesList
              s0 << r4
              if r4
                r5 = _nt_SEP
                s0 << r5
                if r5
                  r6 = _nt_probabilityContent
                  s0 << r6
                  if r6
                    r7 = _nt_SEP
                    s0 << r7
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ProbabilityDeclaration0)
          r0.extend(ProbabilityDeclaration1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:ProbabilityDeclaration][start_index] = r0

        r0
      end

      module ProbabilityVariablesList0
        def SEP
          elements[0]
        end

        def probabilityVariableName
          elements[1]
        end
      end

      module ProbabilityVariablesList1
        def SEP1
          elements[0]
        end

        def SEP2
          elements[2]
        end

        def probabilityVariableName
          elements[3]
        end

        def list
          elements[4]
        end

        def SEP3
          elements[5]
        end

        def SEP4
          elements[7]
        end
      end

      module ProbabilityVariablesList2
        def value
          probabilityVariableName.value
        end

        def parents
           list.elements.map { |e| e.elements[1].value }.flatten
        end
      end

      def _nt_probabilityVariablesList
        start_index = index
        if node_cache[:probabilityVariablesList].has_key?(index)
          cached = node_cache[:probabilityVariablesList][index]
          if cached
            node_cache[:probabilityVariablesList][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_SEP
        s0 << r1
        if r1
          if (match_len = has_terminal?("(", false, index))
            r2 = true
            @index += match_len
          else
            terminal_parse_failure('"("')
            r2 = nil
          end
          s0 << r2
          if r2
            r3 = _nt_SEP
            s0 << r3
            if r3
              r4 = _nt_probabilityVariableName
              s0 << r4
              if r4
                s5, i5 = [], index
                loop do
                  i6, s6 = index, []
                  r7 = _nt_SEP
                  s6 << r7
                  if r7
                    r8 = _nt_probabilityVariableName
                    s6 << r8
                  end
                  if s6.last
                    r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
                    r6.extend(ProbabilityVariablesList0)
                  else
                    @index = i6
                    r6 = nil
                  end
                  if r6
                    s5 << r6
                  else
                    break
                  end
                end
                r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
                s0 << r5
                if r5
                  r9 = _nt_SEP
                  s0 << r9
                  if r9
                    if (match_len = has_terminal?(")", false, index))
                      r10 = true
                      @index += match_len
                    else
                      terminal_parse_failure('")"')
                      r10 = nil
                    end
                    s0 << r10
                    if r10
                      r11 = _nt_SEP
                      s0 << r11
                    end
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ProbabilityVariablesList1)
          r0.extend(ProbabilityVariablesList2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:probabilityVariablesList][start_index] = r0

        r0
      end

      module ProbabilityVariableName0
        def value
          self.text_value.to_sym
        end
      end

      def _nt_probabilityVariableName
        start_index = index
        if node_cache[:probabilityVariableName].has_key?(index)
          cached = node_cache[:probabilityVariableName][index]
          if cached
            node_cache[:probabilityVariableName][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_WORD
        r0.extend(ProbabilityVariableName0)
        r0.extend(ProbabilityVariableName0)

        node_cache[:probabilityVariableName][start_index] = r0

        r0
      end

      module ProbabilityContent0
        def SEP
          elements[0]
        end

        def Property
          elements[1]
        end
      end

      module ProbabilityContent1
        def SEP1
          elements[0]
        end

        def SEP2
          elements[2]
        end

        def list
          elements[3]
        end

        def SEP3
          elements[4]
        end

        def SEP4
          elements[6]
        end
      end

      module ProbabilityContent2
        def cpt
           distributions = list.elements.select { |e| e.respond_to?(:given) }.map do |e|
             {given: e.given,
              distribution: e.distribution}
           end
           table = list.elements.select { |e| e.respond_to?(:table) }.map do |e|
            {table: e.table}
           end
           if distributions.empty? && !table.empty?
             return table.first
           elsif !distributions.empty? && table.empty?
             return distributions
           elsif distributions.empty? && table.empty?
             raise "Either distributions or table must be provided"
           else
             raise "Both - distributions or table cannot be provided at the same time"
           end
        end
      end

      def _nt_probabilityContent
        start_index = index
        if node_cache[:probabilityContent].has_key?(index)
          cached = node_cache[:probabilityContent][index]
          if cached
            node_cache[:probabilityContent][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_SEP
        s0 << r1
        if r1
          if (match_len = has_terminal?("{", false, index))
            r2 = true
            @index += match_len
          else
            terminal_parse_failure('"{"')
            r2 = nil
          end
          s0 << r2
          if r2
            r3 = _nt_SEP
            s0 << r3
            if r3
              s4, i4 = [], index
              loop do
                i5 = index
                i6, s6 = index, []
                r7 = _nt_SEP
                s6 << r7
                if r7
                  r8 = _nt_Property
                  s6 << r8
                end
                if s6.last
                  r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
                  r6.extend(ProbabilityContent0)
                else
                  @index = i6
                  r6 = nil
                end
                if r6
                  r6 = SyntaxNode.new(input, (index-1)...index) if r6 == true
                  r5 = r6
                else
                  r9 = _nt_ProbabilityDefaultEntry
                  if r9
                    r9 = SyntaxNode.new(input, (index-1)...index) if r9 == true
                    r5 = r9
                  else
                    r10 = _nt_ProbabilityEntry
                    if r10
                      r10 = SyntaxNode.new(input, (index-1)...index) if r10 == true
                      r5 = r10
                    else
                      r11 = _nt_ProbabilityTable
                      if r11
                        r11 = SyntaxNode.new(input, (index-1)...index) if r11 == true
                        r5 = r11
                      else
                        @index = i5
                        r5 = nil
                      end
                    end
                  end
                end
                if r5
                  s4 << r5
                else
                  break
                end
              end
              r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
              s0 << r4
              if r4
                r12 = _nt_SEP
                s0 << r12
                if r12
                  if (match_len = has_terminal?("}", false, index))
                    r13 = true
                    @index += match_len
                  else
                    terminal_parse_failure('"}"')
                    r13 = nil
                  end
                  s0 << r13
                  if r13
                    r14 = _nt_SEP
                    s0 << r14
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ProbabilityContent1)
          r0.extend(ProbabilityContent2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:probabilityContent][start_index] = r0

        r0
      end

      module ProbabilityEntry0
        def SEP1
          elements[0]
        end

        def probabilityValuesList
          elements[1]
        end

        def SEP2
          elements[2]
        end

        def floatingPointList
          elements[3]
        end

        def SEP3
          elements[4]
        end

        def SEP4
          elements[6]
        end
      end

      module ProbabilityEntry1
        def given
          probabilityValuesList.values
        end
        def distribution
          floatingPointList.values
        end
      end

      def _nt_ProbabilityEntry
        start_index = index
        if node_cache[:ProbabilityEntry].has_key?(index)
          cached = node_cache[:ProbabilityEntry][index]
          if cached
            node_cache[:ProbabilityEntry][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_SEP
        s0 << r1
        if r1
          r2 = _nt_probabilityValuesList
          s0 << r2
          if r2
            r3 = _nt_SEP
            s0 << r3
            if r3
              r4 = _nt_floatingPointList
              s0 << r4
              if r4
                r5 = _nt_SEP
                s0 << r5
                if r5
                  if (match_len = has_terminal?(";", false, index))
                    r6 = true
                    @index += match_len
                  else
                    terminal_parse_failure('";"')
                    r6 = nil
                  end
                  s0 << r6
                  if r6
                    r7 = _nt_SEP
                    s0 << r7
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ProbabilityEntry0)
          r0.extend(ProbabilityEntry1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:ProbabilityEntry][start_index] = r0

        r0
      end

      module ProbabilityValuesList0
        def SEP
          elements[0]
        end

        def probabilityVariableValue
          elements[1]
        end
      end

      module ProbabilityValuesList1
        def SEP1
          elements[0]
        end

        def SEP2
          elements[2]
        end

        def probabilityVariableValue
          elements[3]
        end

        def list
          elements[4]
        end

        def SEP3
          elements[5]
        end

      end

      module ProbabilityValuesList2
        def values
          [probabilityVariableValue.value] + list.elements.map { |e| e.elements[1].value }
        end
      end

      def _nt_probabilityValuesList
        start_index = index
        if node_cache[:probabilityValuesList].has_key?(index)
          cached = node_cache[:probabilityValuesList][index]
          if cached
            node_cache[:probabilityValuesList][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_SEP
        s0 << r1
        if r1
          if (match_len = has_terminal?("(", false, index))
            r2 = true
            @index += match_len
          else
            terminal_parse_failure('"("')
            r2 = nil
          end
          s0 << r2
          if r2
            r3 = _nt_SEP
            s0 << r3
            if r3
              r4 = _nt_probabilityVariableValue
              s0 << r4
              if r4
                s5, i5 = [], index
                loop do
                  i6, s6 = index, []
                  r7 = _nt_SEP
                  s6 << r7
                  if r7
                    r8 = _nt_probabilityVariableValue
                    s6 << r8
                  end
                  if s6.last
                    r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
                    r6.extend(ProbabilityValuesList0)
                  else
                    @index = i6
                    r6 = nil
                  end
                  if r6
                    s5 << r6
                  else
                    break
                  end
                end
                r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
                s0 << r5
                if r5
                  r9 = _nt_SEP
                  s0 << r9
                  if r9
                    if (match_len = has_terminal?(")", false, index))
                      r10 = true
                      @index += match_len
                    else
                      terminal_parse_failure('")"')
                      r10 = nil
                    end
                    s0 << r10
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ProbabilityValuesList1)
          r0.extend(ProbabilityValuesList2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:probabilityValuesList][start_index] = r0

        r0
      end

      module ProbabilityDefaultEntry0
        def SEP1
          elements[0]
        end

        def floatingPointList
          elements[1]
        end

        def SEP2
          elements[2]
        end

        def SEP3
          elements[4]
        end
      end

      module ProbabilityDefaultEntry1
        def values
          floatingPointList.values
        end
      end

      def _nt_ProbabilityDefaultEntry
        start_index = index
        if node_cache[:ProbabilityDefaultEntry].has_key?(index)
          cached = node_cache[:ProbabilityDefaultEntry][index]
          if cached
            node_cache[:ProbabilityDefaultEntry][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_SEP
        s0 << r1
        if r1
          r2 = _nt_floatingPointList
          s0 << r2
          if r2
            r3 = _nt_SEP
            s0 << r3
            if r3
              if (match_len = has_terminal?(";", false, index))
                r4 = true
                @index += match_len
              else
                terminal_parse_failure('";"')
                r4 = nil
              end
              s0 << r4
              if r4
                r5 = _nt_SEP
                s0 << r5
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ProbabilityDefaultEntry0)
          r0.extend(ProbabilityDefaultEntry1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:ProbabilityDefaultEntry][start_index] = r0

        r0
      end

      module ProbabilityTable0
        def SEP1
          elements[0]
        end

        def TABLEVALUE
          elements[1]
        end

        def SEP2
          elements[2]
        end

        def floatingPointList
          elements[3]
        end

        def SEP3
          elements[4]
        end

        def SEP4
          elements[6]
        end
      end

      module ProbabilityTable1
        def table
          floatingPointList.values
        end
      end

      def _nt_ProbabilityTable
        start_index = index
        if node_cache[:ProbabilityTable].has_key?(index)
          cached = node_cache[:ProbabilityTable][index]
          if cached
            node_cache[:ProbabilityTable][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_SEP
        s0 << r1
        if r1
          r2 = _nt_TABLEVALUE
          s0 << r2
          if r2
            r3 = _nt_SEP
            s0 << r3
            if r3
              r4 = _nt_floatingPointList
              s0 << r4
              if r4
                r5 = _nt_SEP
                s0 << r5
                if r5
                  if (match_len = has_terminal?(";", false, index))
                    r6 = true
                    @index += match_len
                  else
                    terminal_parse_failure('";"')
                    r6 = nil
                  end
                  s0 << r6
                  if r6
                    r7 = _nt_SEP
                    s0 << r7
                  end
                end
              end
            end
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(ProbabilityTable0)
          r0.extend(ProbabilityTable1)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:ProbabilityTable][start_index] = r0

        r0
      end

      module FloatingPointList0
        def SEP
          elements[0]
        end

        def floatingPointToken
          elements[1]
        end
      end

      module FloatingPointList1
        def SEP
          elements[0]
        end

        def floatingPointToken
          elements[1]
        end

        def list
          elements[2]
        end
      end

      module FloatingPointList2
        def values
          [floatingPointToken.value] + list.elements.map {|e| e.elements[1]}.select { |e| e.respond_to?(:value) }.map(&:value)
        end
      end

      def _nt_floatingPointList
        start_index = index
        if node_cache[:floatingPointList].has_key?(index)
          cached = node_cache[:floatingPointList][index]
          if cached
            node_cache[:floatingPointList][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_SEP
        s0 << r1
        if r1
          r2 = _nt_floatingPointToken
          s0 << r2
          if r2
            s3, i3 = [], index
            loop do
              i4, s4 = index, []
              r5 = _nt_SEP
              s4 << r5
              if r5
                r6 = _nt_floatingPointToken
                s4 << r6
              end
              if s4.last
                r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
                r4.extend(FloatingPointList0)
              else
                @index = i4
                r4 = nil
              end
              if r4
                s3 << r4
              else
                break
              end
            end
            r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
            s0 << r3
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(FloatingPointList1)
          r0.extend(FloatingPointList2)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:floatingPointList][start_index] = r0

        r0
      end

      module FloatingPointToken0
        def value
          self.text_value.to_f
        end
      end

      def _nt_floatingPointToken
        start_index = index
        if node_cache[:floatingPointToken].has_key?(index)
          cached = node_cache[:floatingPointToken][index]
          if cached
            node_cache[:floatingPointToken][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_FLOATING_POINT_LITERAL
        r0.extend(FloatingPointToken0)
        r0.extend(FloatingPointToken0)

        node_cache[:floatingPointToken][start_index] = r0

        r0
      end

      def _nt_Property
        start_index = index
        if node_cache[:Property].has_key?(index)
          cached = node_cache[:Property][index]
          if cached
            node_cache[:Property][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        r0 = _nt_PROPERTYSTRING

        node_cache[:Property][start_index] = r0

        r0
      end

      def _nt_NETWORK
        start_index = index
        if node_cache[:NETWORK].has_key?(index)
          cached = node_cache[:NETWORK][index]
          if cached
            node_cache[:NETWORK][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        if (match_len = has_terminal?('network', false, index))
          r0 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'network\'')
          r0 = nil
        end

        node_cache[:NETWORK][start_index] = r0

        r0
      end

      def _nt_VARIABLE
        start_index = index
        if node_cache[:VARIABLE].has_key?(index)
          cached = node_cache[:VARIABLE][index]
          if cached
            node_cache[:VARIABLE][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        if (match_len = has_terminal?('variable', false, index))
          r0 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'variable\'')
          r0 = nil
        end

        node_cache[:VARIABLE][start_index] = r0

        r0
      end

      def _nt_PROBABILITY
        start_index = index
        if node_cache[:PROBABILITY].has_key?(index)
          cached = node_cache[:PROBABILITY][index]
          if cached
            node_cache[:PROBABILITY][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        if (match_len = has_terminal?('probability', false, index))
          r0 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'probability\'')
          r0 = nil
        end

        node_cache[:PROBABILITY][start_index] = r0

        r0
      end

      def _nt_PROPERTY
        start_index = index
        if node_cache[:PROPERTY].has_key?(index)
          cached = node_cache[:PROPERTY][index]
          if cached
            node_cache[:PROPERTY][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        if (match_len = has_terminal?('property', false, index))
          r0 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'property\'')
          r0 = nil
        end

        node_cache[:PROPERTY][start_index] = r0

        r0
      end

      def _nt_VARIABLETYPE
        start_index = index
        if node_cache[:VARIABLETYPE].has_key?(index)
          cached = node_cache[:VARIABLETYPE][index]
          if cached
            node_cache[:VARIABLETYPE][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        if (match_len = has_terminal?('type', false, index))
          r0 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'type\'')
          r0 = nil
        end

        node_cache[:VARIABLETYPE][start_index] = r0

        r0
      end

      def _nt_DISCRETE
        start_index = index
        if node_cache[:DISCRETE].has_key?(index)
          cached = node_cache[:DISCRETE][index]
          if cached
            node_cache[:DISCRETE][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        if (match_len = has_terminal?('discrete', false, index))
          r0 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'discrete\'')
          r0 = nil
        end

        node_cache[:DISCRETE][start_index] = r0

        r0
      end

      def _nt_DEFAULTVALUE
        start_index = index
        if node_cache[:DEFAULTVALUE].has_key?(index)
          cached = node_cache[:DEFAULTVALUE][index]
          if cached
            node_cache[:DEFAULTVALUE][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        if (match_len = has_terminal?('default', false, index))
          r0 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'default\'')
          r0 = nil
        end

        node_cache[:DEFAULTVALUE][start_index] = r0

        r0
      end

      def _nt_TABLEVALUE
        start_index = index
        if node_cache[:TABLEVALUE].has_key?(index)
          cached = node_cache[:TABLEVALUE][index]
          if cached
            node_cache[:TABLEVALUE][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        if (match_len = has_terminal?('table', false, index))
          r0 = instantiate_node(SyntaxNode,input, index...(index + match_len))
          @index += match_len
        else
          terminal_parse_failure('\'table\'')
          r0 = nil
        end

        node_cache[:TABLEVALUE][start_index] = r0

        r0
      end

      module WORD0
        def LETTER
          elements[0]
        end

      end

      def _nt_WORD
        start_index = index
        if node_cache[:WORD].has_key?(index)
          cached = node_cache[:WORD][index]
          if cached
            node_cache[:WORD][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_LETTER
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            i3 = index
            r4 = _nt_LETTER
            if r4
              r4 = SyntaxNode.new(input, (index-1)...index) if r4 == true
              r3 = r4
            else
              r5 = _nt_DIGIT
              if r5
                r5 = SyntaxNode.new(input, (index-1)...index) if r5 == true
                r3 = r5
              else
                @index = i3
                r3 = nil
              end
            end
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(WORD0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:WORD][start_index] = r0

        r0
      end

      def _nt_LETTER
        start_index = index
        if node_cache[:LETTER].has_key?(index)
          cached = node_cache[:LETTER][index]
          if cached
            node_cache[:LETTER][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        if has_terminal?(@regexps[gr = '\A[a-zA-Z_-]'] ||= Regexp.new(gr), :regexp, index)
          r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure('[a-zA-Z_-]')
          r0 = nil
        end

        node_cache[:LETTER][start_index] = r0

        r0
      end

      def _nt_VALUE
        start_index = index
        if node_cache[:VALUE].has_key?(index)
          cached = node_cache[:VALUE][index]
          if cached
            node_cache[:VALUE][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        s0, i0 = [], index
        loop do
          if has_terminal?(@regexps[gr = '\A[/<>=.+a-zA-Z_0-9-]'] ||= Regexp.new(gr), :regexp, index)
            r1 = true
            @index += 1
          else
            terminal_parse_failure('[/<>=.+a-zA-Z_0-9-]')
            r1 = nil
          end
          if r1
            s0 << r1
          else
            break
          end
        end
        if s0.empty?
          @index = i0
          r0 = nil
        else
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        end

        node_cache[:VALUE][start_index] = r0

        r0
      end

      def _nt_DIGIT
        start_index = index
        if node_cache[:DIGIT].has_key?(index)
          cached = node_cache[:DIGIT][index]
          if cached
            node_cache[:DIGIT][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        if has_terminal?(@regexps[gr = '\A[0-9]'] ||= Regexp.new(gr), :regexp, index)
          r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure('[0-9]')
          r0 = nil
        end

        node_cache[:DIGIT][start_index] = r0

        r0
      end

      module DECIMALLITERAL0
        def DIGIT
          elements[0]
        end

      end

      def _nt_DECIMAL_LITERAL
        start_index = index
        if node_cache[:DECIMAL_LITERAL].has_key?(index)
          cached = node_cache[:DECIMAL_LITERAL][index]
          if cached
            node_cache[:DECIMAL_LITERAL][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_DIGIT
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            r3 = _nt_DIGIT
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(DECIMALLITERAL0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:DECIMAL_LITERAL][start_index] = r0

        r0
      end

      module FLOATINGPOINTLITERAL0
      end

      module FLOATINGPOINTLITERAL1
      end

      module FLOATINGPOINTLITERAL2
        def EXPONENT
          elements[1]
        end
      end

      def _nt_FLOATING_POINT_LITERAL
        start_index = index
        if node_cache[:FLOATING_POINT_LITERAL].has_key?(index)
          cached = node_cache[:FLOATING_POINT_LITERAL][index]
          if cached
            node_cache[:FLOATING_POINT_LITERAL][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0 = index
        i1, s1 = index, []
        s2, i2 = [], index
        loop do
          r3 = _nt_DIGIT
          if r3
            s2 << r3
          else
            break
          end
        end
        if s2.empty?
          @index = i2
          r2 = nil
        else
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
        end
        s1 << r2
        if r2
          if (match_len = has_terminal?('.', false, index))
            r4 = true
            @index += match_len
          else
            terminal_parse_failure('\'.\'')
            r4 = nil
          end
          s1 << r4
          if r4
            s5, i5 = [], index
            loop do
              r6 = _nt_DIGIT
              if r6
                s5 << r6
              else
                break
              end
            end
            r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
            s1 << r5
            if r5
              r8 = _nt_EXPONENT
              if r8
                r7 = r8
              else
                r7 = instantiate_node(SyntaxNode,input, index...index)
              end
              s1 << r7
            end
          end
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(FLOATINGPOINTLITERAL0)
        else
          @index = i1
          r1 = nil
        end
        if r1
          r1 = SyntaxNode.new(input, (index-1)...index) if r1 == true
          r0 = r1
        else
          i9, s9 = index, []
          if (match_len = has_terminal?('.', false, index))
            r10 = true
            @index += match_len
          else
            terminal_parse_failure('\'.\'')
            r10 = nil
          end
          s9 << r10
          if r10
            s11, i11 = [], index
            loop do
              r12 = _nt_DIGIT
              if r12
                s11 << r12
              else
                break
              end
            end
            if s11.empty?
              @index = i11
              r11 = nil
            else
              r11 = instantiate_node(SyntaxNode,input, i11...index, s11)
            end
            s9 << r11
            if r11
              r14 = _nt_EXPONENT
              if r14
                r13 = r14
              else
                r13 = instantiate_node(SyntaxNode,input, index...index)
              end
              s9 << r13
            end
          end
          if s9.last
            r9 = instantiate_node(SyntaxNode,input, i9...index, s9)
            r9.extend(FLOATINGPOINTLITERAL1)
          else
            @index = i9
            r9 = nil
          end
          if r9
            r9 = SyntaxNode.new(input, (index-1)...index) if r9 == true
            r0 = r9
          else
            i15, s15 = index, []
            s16, i16 = [], index
            loop do
              r17 = _nt_DIGIT
              if r17
                s16 << r17
              else
                break
              end
            end
            if s16.empty?
              @index = i16
              r16 = nil
            else
              r16 = instantiate_node(SyntaxNode,input, i16...index, s16)
            end
            s15 << r16
            if r16
              r18 = _nt_EXPONENT
              s15 << r18
            end
            if s15.last
              r15 = instantiate_node(SyntaxNode,input, i15...index, s15)
              r15.extend(FLOATINGPOINTLITERAL2)
            else
              @index = i15
              r15 = nil
            end
            if r15
              r15 = SyntaxNode.new(input, (index-1)...index) if r15 == true
              r0 = r15
            else
              @index = i0
              r0 = nil
            end
          end
        end

        node_cache[:FLOATING_POINT_LITERAL][start_index] = r0

        r0
      end

      module EXPONENT0
      end

      def _nt_EXPONENT
        start_index = index
        if node_cache[:EXPONENT].has_key?(index)
          cached = node_cache[:EXPONENT][index]
          if cached
            node_cache[:EXPONENT][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        if has_terminal?(@regexps[gr = '\A[eE]'] ||= Regexp.new(gr), :regexp, index)
          r1 = true
          @index += 1
        else
          terminal_parse_failure('[eE]')
          r1 = nil
        end
        s0 << r1
        if r1
          if has_terminal?(@regexps[gr = '\A[+-]'] ||= Regexp.new(gr), :regexp, index)
            r3 = true
            @index += 1
          else
            terminal_parse_failure('[+-]')
            r3 = nil
          end
          if r3
            r2 = r3
          else
            r2 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r2
          if r2
            s4, i4 = [], index
            loop do
              r5 = _nt_DIGIT
              if r5
                s4 << r5
              else
                break
              end
            end
            if s4.empty?
              @index = i4
              r4 = nil
            else
              r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            end
            s0 << r4
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(EXPONENT0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:EXPONENT][start_index] = r0

        r0
      end

      module PROPERTYSTRING0
        def PROPERTY
          elements[0]
        end

      end

      def _nt_PROPERTYSTRING
        start_index = index
        if node_cache[:PROPERTYSTRING].has_key?(index)
          cached = node_cache[:PROPERTYSTRING][index]
          if cached
            node_cache[:PROPERTYSTRING][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        i0, s0 = index, []
        r1 = _nt_PROPERTY
        s0 << r1
        if r1
          s2, i2 = [], index
          loop do
            if index < input_length
              r3 = true
              @index += 1
            else
              terminal_parse_failure("any character")
              r3 = nil
            end
            if r3
              s2 << r3
            else
              break
            end
          end
          r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
          s0 << r2
          if r2
            if (match_len = has_terminal?(';', false, index))
              r4 = true
              @index += match_len
            else
              terminal_parse_failure('\';\'')
              r4 = nil
            end
            s0 << r4
          end
        end
        if s0.last
          r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          r0.extend(PROPERTYSTRING0)
        else
          @index = i0
          r0 = nil
        end

        node_cache[:PROPERTYSTRING][start_index] = r0

        r0
      end

      def _nt_SEP
        start_index = index
        if node_cache[:SEP].has_key?(index)
          cached = node_cache[:SEP][index]
          if cached
            node_cache[:SEP][index] = cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
            @index = cached.interval.end
          end
          return cached
        end

        s0, i0 = [], index
        loop do
          if has_terminal?(@regexps[gr = '\A[\\r\\n\\t ,|]'] ||= Regexp.new(gr), :regexp, index)
            r1 = true
            @index += 1
          else
            terminal_parse_failure('[\\r\\n\\t ,|]')
            r1 = nil
          end
          if r1
            s0 << r1
          else
            break
          end
        end
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)

        node_cache[:SEP][start_index] = r0

        r0
      end

    end

    class BifParser < Treetop::Runtime::CompiledParser
      include Bif
    end

  end
end
